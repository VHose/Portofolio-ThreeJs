<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunga 3D Gio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); // Dark background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 100);
        spotLight.position.set(10, 10, 10);
        spotLight.angle = 0.3;
        spotLight.penumbra = 1;
        spotLight.castShadow = true;
        scene.add(spotLight);

        const pointLight = new THREE.PointLight(0xffaa00, 50, 20);
        pointLight.position.set(-5, 5, 5);
        scene.add(pointLight);

        // Flower Group
        const flowerGroup = new THREE.Group();
        scene.add(flowerGroup);

        // 1. Stem
        const stemGeometry = new THREE.CylinderGeometry(0.2, 0.2, 8, 32);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.y = -4;
        stem.castShadow = true;
        stem.receiveShadow = true;
        flowerGroup.add(stem);

        // 2. Head Group (Petals + Center)
        const headGroup = new THREE.Group();
        headGroup.position.y = 0; // Top of the stem (which is at -4 center, so top is near 0)
        // Adjust stem position so its top is at origin for headGroup?
        // Let's keep stem at y=-4 (height 8 goes from -8 to 0). So head at 0 is correct.
        flowerGroup.add(headGroup);

        // Flower Center
        const centerGeometry = new THREE.SphereGeometry(1.2, 32, 32);
        const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.5 }); // Gold
        const center = new THREE.Mesh(centerGeometry, centerMaterial);
        center.castShadow = true;
        headGroup.add(center);

        // Petals
        const petalCount = 8;
        const petalGeometry = new THREE.SphereGeometry(1, 32, 32);
        // Scale to make it petal-like
        petalGeometry.scale(1, 0.4, 2);

        const petalMaterial = new THREE.MeshStandardMaterial({
            color: 0xFF69B4, // HotPink
            roughness: 0.2,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2;
            const petal = new THREE.Mesh(petalGeometry, petalMaterial);

            // Position around center
            const radius = 1.3;
            petal.position.x = Math.cos(angle) * radius;
            petal.position.y = Math.sin(angle) * radius;
            petal.position.z = 0;

            // Rotate to point outward
            petal.rotation.z = angle - Math.PI / 2;

            // Tilt slightly forward/backward for 3D effect
            petal.rotation.x = 0.3;

            petal.castShadow = true;
            headGroup.add(petal);
        }

        // Add a second layer of petals, smaller and offset
        const innerPetalCount = 6;
        const innerPetalMaterial = new THREE.MeshStandardMaterial({ color: 0xFF1493 }); // DeepPink
        for (let i = 0; i < innerPetalCount; i++) {
            const angle = (i / innerPetalCount) * Math.PI * 2 + (Math.PI / innerPetalCount); // Offset angle
            const petal = new THREE.Mesh(petalGeometry, innerPetalMaterial);
            petal.scale.set(0.8, 0.8, 0.8);

            const radius = 0.8;
            petal.position.x = Math.cos(angle) * radius;
            petal.position.y = Math.sin(angle) * radius;
            petal.position.z = 0.5; // Slightly forward

            petal.rotation.z = angle - Math.PI / 2;
            petal.rotation.x = 0.5; // More tilt

            petal.castShadow = true;
            headGroup.add(petal);
        }

        // 3. Text "Gio"
        const loader = new FontLoader();
        loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textGeometry = new TextGeometry('Gio', {
                font: font,
                size: 0.8,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
            });

            // Center the text
            textGeometry.computeBoundingBox();
            const centerOffset = - 0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
            textGeometry.translate(centerOffset, 0, 0);

            const textMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            textMesh.position.z = 1.5; // In front of the flower center
            textMesh.position.y = -0.3; // Center vertically relative to flower center

            headGroup.add(textMesh);
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Rotate the flower group
            // flowerGroup.rotation.y += 0.01; 

            // Or just rotate the head (petals + text) and maybe keep stem static?
            // The prompt says "bunga 3d ... yang bisa berputar" (3d flower that can rotate).
            // Usually spinning the whole flower is good, or just the head.
            flowerGroup.rotation.y += 0.01;

            // Make it bob up and down slightly
            flowerGroup.position.y = Math.sin(Date.now() * 0.002) * 0.5;

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();
    </script>
</body>

</html>